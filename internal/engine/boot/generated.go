// Released under an MIT license. See LICENSE.

// Package boot generated by "generate.oh"
package boot

// Script returns the boot script for oh.
func Script() string { //nolint:funlen
	return `
# For debugging.
define show: syntax ((args)) = {
    debug $args
}

define list: method ((l)) = {
    return $l
}

sys export throw: method (msg) = {
	_stack_trace_
	debug $msg
	fatal 1
}

define and: syntax ((lst)) e = {
    define r $False
    while (not (is-null $lst)) {
        set r: e eval (lst head)
        if (not $r) {
            return $r
        }
        set lst (lst tail)
    }
    return $r
}

define or: syntax ((lst)) e = {
    define r $False
    while (not (is-null $lst)) {
        set r: e eval (lst head)
        if $r {
            return $r
        }
        set lst (lst tail)
    }
    return $r
}

define source: method (basename) e = {
	define name $basename
	define paths ()

	if (resolves OHPATH) {
		set paths: _split_ : $OHPATH
	}

	while (and (not (is-null $paths)) (not (exists $name))) {
		set name: _join_ (paths head) / $basename
		set paths: paths tail
	}

	define f: open r- $name

	define r: cons () ()
	define c $r
	while (define l: f read-list) {
		c set-tail (cons $l ())
		set c: c tail
	}
	set c: r tail

	f close

	define rval $False
	define eval-list: method (first rest) = {
		if (is-null $first) {
			return $rval
		}
		set rval: e eval $first
		eval-list (rest head) (rest tail)
	}
	eval-list (c head) (c tail)

	return $rval
}

define quasiquote: syntax (cell) e = {
    if (not (is-cons $cell)) {
        return $cell
    }

    if (is-null $cell) {
        return $cell
    }

    if (eq unquote (cell head)) {
        return (e eval (cell get 1))
    }

    cons {
        e eval (list quasiquote (cell head))
        e eval (list quasiquote (cell tail))
    }
}

define catch: syntax (name (clause)) e = {
    define body: list throw (list _lookup_ $name)

    if (is-null $clause) {
        set body: list body
    } else {
        set body: clause append $body
    }

    define defn: list method (list $name throw) =
    defn extend $body

    define handler: e eval $defn

    define _return_: e eval (list _lookup_ return)
    define _throw_ $throw

    e export throw: method (msg) = {
        #export throw $_throw_
        _return_ (handler $msg $_throw_)
    }
}

define _rew_: method (cmd) = {
    quasiquote ((method () = {
        define r $False

        catch ex {
            return (cons $r $ex)
        }

        set r (unquote $cmd)

        throw ()
    }))
}

define _few_: method (c n) = {
    define r $False

    define zero (|number 0|)
    while (not (eq $n $zero)) {
        define rex: c read

        set r: rex head

        define ex: rex tail
        if (not (is-null $ex)) {
            throw $ex
        }

        set n: add $n -1
    }

    return $r
}

define _pipe_output_to_: syntax (right (left)) e = {
    define c: channel 2
    define p: pipe

    spawn {
        export _stdout_ $p
        c write (e eval (_rew_ $left))
        p _writer_close_
    } 

    block {
        export _stdin_ $p
        c write (e eval (_rew_ $right))
        p _reader_close_
    }

    _few_ $c (|number 2|)
}
`
}

//go:generate ./generate.oh
//go:generate go fmt generated.go
